package matchmaker

import (
	"crypto/tls"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"sync"

	agones "agones.dev/agones/pkg/apis/agones/v1"
)

// ServerFinder struct hold required data
type ServerFinder struct {
	mutex      sync.Mutex
	agonesPort int
	agonesHost string
	servers    map[uint32]*agones.GameServerStatus
}

// AgonesOption struct define engine option configuration
type AgonesOption struct {
	Port int
	Host string
}

// NewFinder function return ServerFinder struct
func NewFinder(opt AgonesOption) *ServerFinder {
	fmt.Println("Agones Host:", opt.Host)
	fmt.Println("Agones Port:", opt.Port)
	return &ServerFinder{
		agonesPort: opt.Port,
		agonesHost: opt.Host,
		servers:    make(map[uint32]*agones.GameServerStatus),
	}
}

// The structure of the json response
type result struct {
	Status interface{} `json:"status"`
}

// GetServer get game server struct
func (s *ServerFinder) GetServer(poolID uint32) *agones.GameServerStatus {
	if _, ok := s.servers[poolID]; !ok {

		///
		gs := new(agones.GameServerStatus)

		jsonErr := s.getJSON(fmt.Sprintf("%s:%d/address", s.agonesHost, s.agonesPort), gs)
		if jsonErr != nil {
			fmt.Printf("Error with JSON %s\n", jsonErr)
			return nil
		}

		if gs == nil {
			fmt.Printf("Cannot find server")
			return nil
		}

		fmt.Printf("Found %s\n", gs.Address)
		fmt.Printf("Port %d\n", gs.Ports[0].Port)

		s.servers[poolID] = gs
		return gs
	}

	return s.servers[poolID]
}

func (s *ServerFinder) getJSON(url string, target interface{}) error {
	// Generated by curl-to-Go: https://mholt.github.io/curl-to-go
	// TODO: This is insecure; use only in dev environments.
	tr := &http.Transport{
		TLSClientConfig: &tls.Config{InsecureSkipVerify: true},
	}
	client := &http.Client{Transport: tr}

	req, err := http.NewRequest("GET", url, nil)
	if err != nil {
		println("1", url, err.Error)
		return err
	}
	req.SetBasicAuth("v1GameClientKey", "EAEC945C371B2EC361DE399C2F11E")

	resp, err := client.Do(req)
	if err != nil {
		fmt.Printf("2 %s\n", err)
		return err
	}
	defer resp.Body.Close()

	//IO reading of the body
	body, err := ioutil.ReadAll(resp.Body)

	fmt.Println(string(body))

	//Read JSON
	return json.Unmarshal(body, &result{target})
}
